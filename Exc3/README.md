# Анализ текущей архитектуры

Рассматривается внутреннее и внешнее взаимодействие трёх сервисов:

1. `core-app` — отвечает за отображение доступных клиенту продуктов, оформление заявок на новые страховки и отображение уже оформленных.
2. `ins-comp-settlement` — сервис взаиморасчётов со страховыми компаниями. Раз в месяц он отправляет перечень оформленных страховок в страховые компании для расчёта выплаты агентских премий.
3. `ins-product-aggregator` — сервис интеграции со страховыми компаниями для получения информации о продуктах.

Из внешних взаимодействий рассматривается только получение информации по продуктам и тарифам в сервисе `ins-product-aggregator`.


## Проблема 1: синхронное взаимодействие с внешними системами

### Общее

Сервисы `core-app` и `ins-comp-settlement` взаимодействуют с внешними системами через сервис `ins-product-aggregator`. При этом взаимодействие происходит синхронно: при обращении сервиса `core-app`/`ins-comp-settlement` к сервису `ins-product-aggregator`, данный сервис выполняет опрос всех внешних систем страховых компаний. 

Т.к. всё это происходит синхронно, то наши основные сервисы зависят от стабильности работы внешних систем. При увеличении количества внешних систем с 5 до 10 данная зависимость усиливается.

### Проблемы `core-app` и внешки

Раз в 15 минут `core-app` ходит во внешние системы (через наш аггрегатов) для получения информации по продуктам.
В задании не сказано, что происходит, если одна из страховых не отвечает, но предположим, что в данном случае приходит только информация по ответившим страховым, и скорей всего мы не показываем пользователю устаревшие данные, т.к. это может привести к дополнительным выплатам страховым с нашей стороны (пользователь оформил страховку по меньшей цене чем она есть, а значит нам нужно выплатить страховой разницу или взять меньший процент).

Поэтому можно предположить, что иногда раз в 15 минут, часть продуктов может быть недоступна для пользователей. При увеличении количества внешних систем с 5 до 10 количество недоступных продуктов может вырасти.

### Проблемы `ins-comp-settlement` и внешки

Раз в сутки `ins-comp-settlement` ходит во внешние системы.
Если в этот момент внешние системы будут недоступны, то мы не получим нужную информацию для выполнения работы. В задании не сказано, что в этом случае происходит. Предположим, что в этом случае часть реестра оформленных страховок будет невалидна.

Наличие невалидных оформленных страховок в реестре может приводить к привлечению ручного труда, чтобы это поправить.

## Проблема 2: синхронное взаимодействие между `ins-comp-settlement` и `core-app`

Раз в сутки `ins-comp-settlement` забирает из `core-app` оформленные за день страховки.
Такой запрос может приводить к большой нагрузке в `core-app`, что может сказаться на стабильности этого сервиса. 
Стабильность такого запроса сложно спрогнозировать, т.к. она зависит от количества оформленных страховок.


## Итог

Таким образом можно обобщить выделенные проблемы в следующие две:
1. Проблема доступности информации по продуктам и тарифам (для пользователя и наших внутренних систем)
2. Излишняя синхронная нагрузка на `core-app`


# Решение

## Проблема доступности информации по продуктам и тарифам (для пользователя и наших внутренних систем)

Для решения данной проблемы перейдём с синхронного взаимодействия на ассинхронное.

Сервис `ins-product-aggregator` хоть и назван аггрегатором, но таковым фактически не является, т.к. не владеет какими-либо сущностями, а выполняет только роль прокси. В основном мы ходим во внешние системы раз в 15 минут, но в задании не указано подобных ограничений, а значит мы можем ходить чаще. Поэтому в данном сервисе будут выполнены следующие шаги:
1. Сервису будет выдана база данных. В ней он будет хранить и обновлять информацию по страховым продуктам и тарифам.
2. Под каждую страховую в данном сервисе будет заведён свой воркер (отдельный поток или инстанс), который: 
    2.1. раз в минуту (или чаще/реже) будет опрашивать конкретную страховую
    2.2. при получении данных от страховой сверяется с сохранёнными данными в БД и обновляет их в БД
    2.3. если данные по продуктам и тарифам изменились, то отправляет об этом событие в брокер сообщений (`для данного функционала Transactional Outbox необязателен`)
3. REST API сохраним, т.к. возможно каким-то системам нужно будет получать данные без завязки на события

Таким образом `ins-product-aggregator` отправляет асинхронные события в брокер сообщений, если изменились условия по продукту, тарифам или появился новый продукт/тариф. На данные события подписываются сервисы `core-app` и `ins-comp-settlement`, что позволяет убрать из них синхронные запросы в `ins-product-aggregator` и уменьшить их зависимость от внешних систем страховых. При этом `core-app` может следить за актуальностью информации и отмечать продукты/тарифы как устаревшими или вообще убирать их из выдачи, но т.к. мы чаще и асинхронно опрашиваем страховые, то количество ситуаций, когда лаг превышает 15 и более минут, должно быть практически нулевым.

## Излишняя синхронная нагрузка на `core-app`

Для решения данной проблемы мы также перейдём с синхронного взаимодействия на ассинхронное.

Сервис `core-app` владеет сущностью "Оформленная страховка". Предлагается отсылать события, когда данная сущность создаётся или изменяется (например, происходит расторжение договора и удаление страховки м/у пользователем и страховой компанией). Для `отправки данного события в брокер сообщений необходимо применить паттерн Transactional Outbox`, т.к. нам гарантированно необходимо сообщить о всех изменениях в нашей сущности.

Сервис `ins-comp-settlement` подписывается на события от `core-app`, что позволяет убрать синхронные REST запросы между ними и сервис `ins-comp-settlement` всегда получает актуальную информацию по оформленным страховкам.


