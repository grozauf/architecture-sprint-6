# Пояснения к схеме

## Функциональные требования

1. Пользователь может оформить заявку на ОСАГО
2. Пользователю отображаются предложения от страховых по его заявке
3. Предложения от каждой страховой компании отображаются сразу, как только от неё пришёл ответ

## Нефункциональные требования

1. 2.5K RPS на оформление заявки
2. максимум 60 секунд для получения решения от страховой

## Предлагаемая архитектура

Т.к. предложения от каждой страховой нужно отображать сразу, то стоит использовать асинхронное взаимодействие между `core-app` и `osago-aggregator` - это позволит асинхронно взаимодействовать со страховыми и показывать ответ при его получении, также это позволит выдержать 2.5К RPS на формление заявки.

1. При оформлении заявки `core-app` отсылает событие о создании новой заявки ОСАГО (используется паттерн Transactional Outbox), на которое подписан сервис `osago-aggregator`. Также в данном событии может приходить информация по отмене новой заявки ОСАГО. В этом случае `osago-aggregator` прекращает все действия по данной заявке и удаляет её из своей БД.
2. `osago-aggregator` получив событие от `core-app` сохраняет заявку у себя в БД и отсылает запрос на создание заявки в страховую, дальше взводит таймаут на 60с и пытается получить ответ по заявке от страховой (Retry+Timeout). `osago-aggregator` на каждых этапах обработки заявки пользователя отсылает событие со статусом обработки заявки, на которое подписано `core-app`, таким образом пользователь может сразу видеть в каких страховых создана заявка и ожидается ответ, и какие страховые уже сформировали своё предложение.
    2.1. Обработка событий от `core-app` выполняется в воркерах (`обработчики событий`), которые создают в БД заявку в статусе инициализации (для каждой страховой будет заведён свой отдельный статус)
    2.2. Далее другие воркеры (`обработчики заявок`) вытаскивают из БД заявки в статусе инициализации, помечают их как взятые в работу и выполняют работу по согласованию данной заявки со страховыми: создание заявки, получение решения. На каждом этапе выполняется смена статуса заявки от пользователя, сохранение необходимых данных и отправка события о смене статуса заявки (используется паттерн Transactional Outbox) с необходимыми данными, например, с данными по предложению от страховой. Для взаимодействий со страховыми используем паттерны Timeout (у нас есть требование - не ждать решения более 60с) и Retry (если таймаут не закончен и произошёл сбой, то делаем ретрай).

### Заметки по архитекруте

- Все воркеры `обработчики событий` будут иметь один client id для брокера сообщений, поэтому одно конкретное событие будет обработано только одним воркером, а значит их может быть сколько угодно.
- Заявки от пользователей в БД имеют статусы, данные статусы говорят также и о том какие действия необходимо выполнить с заявкой, а также о том, что данная заявка взята в работу (INIT, CREATE_IN_PROGRESS, CREATED, WAIT_DATA_IN_PROGRESS, GOT_DATA). Поэтому воркеров `обработчики заявок` может быть также сколько угодно, т.к. каждый будет брать заявку, которая не в статусе обработки (некое подобие саги).
- БД нам нужна для хранения и обработки заявок от пользователей.